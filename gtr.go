package main

import (
	"flag"
	"fmt"
	"os"
	"runtime"

	"github.com/fatih/color"
)

func main() {

	// test flags
	var (
		compile            bool
		codegen            bool
		optimize           bool
		optimizeStandalone bool

		clean bool

		invertFlags bool
	)
	test := flag.NewFlagSet("test", flag.ExitOnError)
	test.BoolVar(&clean, "clean", false,
		"Clean out the output directories before running tests")

	test.BoolVar(&codegen, "codegen", false,
		"Generate asm but DON'T optimize")
	test.BoolVar(&compile, "compile", false,
		"Generate asm and optimize")
	test.BoolVar(&optimize, "optimize", false,
		"Optimize asm from -codegen.\n"+
			"\tDifferent to -compile:\n"+
			"\tCode is read back in, after being written to a file")
	test.BoolVar(&optimizeStandalone, "optimizeStandalone", false,
		"Optimize asm written explicitly for testing")

	test.BoolVar(&invertFlags, "invert", false,
		"Inverts all flags, making them subtractive instead of additive")

	// view flags
	var (
		diff  bool
		run   bool
		asm   bool
		build bool
	)
	view := flag.NewFlagSet("view", flag.ExitOnError)
	view.BoolVar(&diff, "diff", false,
		"view as a diff, instead of result and expectation separately")
	view.BoolVar(&run, "run", false,
		"compare results of the run phase of testing")
	view.BoolVar(&asm, "asm", false,
		"compare asm generated by building phase of testing")
	view.BoolVar(&build, "build", false,
		"compare results of the build phase of testing")

	// accept flags
	var all bool
	accept := flag.NewFlagSet("accept", flag.ExitOnError)
	accept.BoolVar(&all, "all", false,
		"accept every test result run in the last testing round")

	if len(os.Args) == 1 {
		helpMessage()
		os.Exit(0)
	}

	command := os.Args[1]
	switch command {
	case "test":
		test.Parse(os.Args[2:])
		testCommand(
			clean,
			codegen, optimize,
			compile,
			optimizeStandalone,
			invertFlags)
	case "view":
		view.Parse(os.Args[2:])
	case "create":
		// do creation tasks
	case "accept":
		accept.Parse(os.Args[2:])
	case "init":
		initDirs()
	case "help":
		fallthrough
	case "-help":
		fallthrough
	case "--help":
		helpMessage()
		os.Exit(0)
	default:
		color.Red("invalid command " + command)
		helpMessage()
		os.Exit(1)
	}

	os.Exit(0)
}

func testCommand(clean, codegen, optimize, compile, optimizeStandalone, invertFlags bool) {
	if invertFlags {
		compile = !compile
		codegen = !codegen
		optimize = !optimize
		optimizeStandalone = !optimizeStandalone

		clean = !clean
	}

	cores := runtime.NumCPU()
	runtime.GOMAXPROCS(cores + 1)

	if clean {
		fmt.Print("CLEANING... ")
		cleanDirs()
		fmt.Println(" done")
	}
	if codegen {
		color.Cyan("GENERATING CODE...")
		batchCodeGen(cores)
		color.Yellow("RUNNING...")
		batchRunUnoptimized(cores)
	}
	if optimize {
		color.Cyan("OPTIMIZING...")
		batchOptimize(cores)
		color.Yellow("RUNNING...")
		batchRunOptimized(cores)
	}
	if compile {
		color.Cyan("GENERATING CODE + OPTIMIZING...")
		batchCompile(cores)
		color.Yellow("RUNNING...")
		batchRunCompiled(cores)
	}
	if optimizeStandalone {
		color.Cyan("OPTIMIZING HAND WRITTEN ASM...")
		batchOptimizeStandalone(cores)
		color.YellowString("RUNNING...")
		batchRunOptimizedStandalone(cores)
	}
}
