package main

import (
	"flag"
	"fmt"
	"os"
	"runtime"
)

type testResult struct {
	name   string
	result bool
}

type testStorageDir struct {
	codegenerator       string
	compiler            string
	optimizer           string
	optimizerStandalone string
}

type testDirTree struct {
	build testStorageDir
	run   testStorageDir
	asm   testStorageDir
}

const (
	bin  = "./bin"
	pika = "./tests/pika"
	asm  = "./tests/asm"

	pikaExt = ".pika"
	asmExt  = ".asm"
	asmoExt = ".asmo"
	txtExt  = ".txt"

	java = "java"
	wine = "wine"
)

var (
	compiler      = []string{"-ea", "-jar", bin + "/pika-compiler.jar"}
	codegenerator = []string{"-ea", "-jar", bin + "/pika-codegen.jar"}
	optimizer     = []string{"-ea", "-jar", bin + "/pika-optimizer.jar"}
	emulator      = []string{bin + "/ASMEmu.exe"}

	result = testDirTree{
		build: testStorageDir{
			codegenerator:       "./result/build/codegenerator",
			compiler:            "./result/build/compiler",
			optimizer:           "./result/build/optimizer",
			optimizerStandalone: "./result/build/optimizer-standalone",
		},
		run: testStorageDir{
			codegenerator:       "./result/run/codegenerator",
			compiler:            "./result/run/compiler",
			optimizer:           "./result/run/optimizer",
			optimizerStandalone: "./result/run/optimizer-standalone",
		},
		asm: testStorageDir{
			codegenerator:       "./result/asm/codegenerator",
			compiler:            "./result/asm/compiler",
			optimizer:           "./result/asm/optimizer",
			optimizerStandalone: "./result/asm/optimizer-standalone",
		},
	}

	expect = testDirTree{
		build: testStorageDir{
			codegenerator:       "./expect/build/codegenerator",
			compiler:            "./expect/build/compiler",
			optimizer:           "./expect/build/optimizer",
			optimizerStandalone: "./expect/build/optimizer-standalone",
		},
		run: testStorageDir{
			codegenerator:       "./expect/run/codegenerator",
			compiler:            "./expect/run/compiler",
			optimizer:           "./expect/run/optimizer",
			optimizerStandalone: "./expect/run/optimizer-standalone",
		},
		asm: testStorageDir{
			codegenerator:       "./expect/asm/codegenerator",
			compiler:            "./expect/asm/compiler",
			optimizer:           "./expect/asm/optimizer",
			optimizerStandalone: "./expect/asm/optimizer-standalone",
		},
	}
)

func main() {

	var (
		compile            bool
		codegen            bool
		optimize           bool
		optimizeStandalone bool

		clean      bool
		initialize bool

		invertFlags bool
	)
	test := flag.NewFlagSet("test", flag.ExitOnError)
	test.BoolVar(&initialize, "init", false,
		"Make the directory structure required for running tests")
	test.BoolVar(&clean, "clean", false,
		"Clean out the output directories before running tests")

	test.BoolVar(&codegen, "codegen", false,
		"Generate asm but DON'T optimize")
	test.BoolVar(&compile, "compile", false,
		"Generate asm and optimize")
	test.BoolVar(&optimize, "optimize", false,
		"Optimize asm from -codegen.\n"+
			"\tDifferent to -compile:\n"+
			"\tCode is read back in, after being written to a file")
	test.BoolVar(&optimizeStandalone, "optimizeStandalone", false,
		"Optimize asm written explicitly for testing")

	test.BoolVar(&invertFlags, "invertFlags", false,
		"Inverts all flags, making them subtractive instead of additive")

	var (
		diff  bool
		run   bool
		asm   bool
		build bool
	)
	view := flag.NewFlagSet("view", flag.ExitOnError)
	view.BoolVar(&diff, "diff", false,
		"view as a diff, instead of result and expectation separately")
	view.BoolVar(&run, "run", false,
		"compare results of the run phase of testing")
	view.BoolVar(&asm, "asm", false,
		"compare asm generated by building phase of testing")
	view.BoolVar(&build, "build", false,
		"compare results of the build phase of testing")

	create := flag.NewFlagSet("create", flag.ExitOnError)

	var all bool
	accept := flag.NewFlagSet("accept", flag.ExitOnError)
	accept.BoolVar(&all, "all", false,
		"accept every test result run in the last testing round")

	if len(os.Args) == 1 {
		helpMessage()
		os.Exit(0)
	}

	switch os.Args[1] {
	case "test":
		test.Parse(os.Args[2:])
	case "view":
		view.Parse(os.Args[2:])
	case "create":
		create.Parse(os.Args[2:])
	case "accept":
		accept.Parse(os.Args[2:])
	case "-help":
		helpMessage()
		os.Exit(0)
	case "--help":
		helpMessage()
		os.Exit(0)
	default:
		fmt.Println("invalid command " + os.Args[1])
		os.Exit(1)
	}

	cores := runtime.NumCPU()
	runtime.GOMAXPROCS(cores + 1)

	if invertFlags {
		compile = !compile
		codegen = !codegen
		optimize = !optimize
		optimizeStandalone = !optimizeStandalone
		// reoptimize = !reoptimize

		clean = !clean
		initialize = !initialize
	}

	if initialize {
		fmt.Print("INITIALIZING... ")
		initDirs()
		fmt.Println(" done")
	}
	if clean {
		fmt.Print("CLEANING... ")
		cleanDirs()
		fmt.Println(" done")
	}
	if codegen {
		fmt.Println("GENERATING CODE...")
		batchCodeGen(cores)
		fmt.Println("RUNNING...")
		batchRunUnoptimized(cores)
	}
	if optimize {
		fmt.Println("OPTIMIZING...")
		batchOptimize(cores)
		fmt.Println("RUNNING...")
		batchRunOptimized(cores)
	}
	if compile {
		fmt.Println("GENERATING CODE + OPTIMIZING...")
		batchCompile(cores)
		fmt.Println("RUNNING...")
		batchRunCompiled(cores)
	}
	if optimizeStandalone {
		fmt.Println("OPTIMIZING HAND WRITTEN ASM...")
		batchOptimizeStandalone(cores)
		fmt.Println("RUNNING...")
		batchRunOptimizedStandalone(cores)
	}

	os.Exit(0)
}
